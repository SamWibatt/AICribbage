import sys
import math

# card handling routines -------------------------------------------------------------------------

def cardstring(card):
    '''card is a number from 0-51; card %4 is rank, where 0 = hearts, 1 = diamonds, 2 = clubs, 3 = spades.
    card / 4 is rank, 0 = ace .. 12 = king
    '''
    if card not in range(0,52):
        print("Illegal card value",card)
        return None
    return 'A234567890JQK'[math.floor(card / 4)] + '♥♦♣♠'[card % 4]

# so for random, let's reproduce arduino's, which is taken from avrlibc's, as shewn here
# https://arduino.stackexchange.com/questions/1481/formula-calculation-of-the-function-random-randomseed

# First, from stdlib:
#
# /**  \ingroup avr_stdlib
# Highest number that can be generated by random(). */
# #define	RANDOM_MAX 0x7FFFFFFF
#
# /**
#  \ingroup avr_stdlib
#      The random() function computes a sequence of pseudo-random integers in the
#      range of 0 to \c RANDOM_MAX (as defined by the header file <stdlib.h>).
#
#      The srandom() function sets its argument \c seed as the seed for a new
#      sequence of pseudo-random numbers to be returned by rand().  These
#      sequences are repeatable by calling srandom() with the same seed value.
#
#      If no seed value is provided, the functions are automatically seeded with
#      a value of 1.
# */
# extern long random(void);
# /**
#  \ingroup avr_stdlib
#    Pseudo-random number generator seeding; see random().
# */
# extern void srandom(unsigned long __seed);


# /*-
#  * Copyright (c) 1990, 1993
#  *	The Regents of the University of California.  All rights reserved.
#  *
#  * Redistribution and use in source and binary forms, with or without
#  * modification, are permitted provided that the following conditions
#  * are met:
#  * 1. Redistributions of source code must retain the above copyright
#  *    notice, this list of conditions and the following disclaimer.
#  * 2. Redistributions in binary form must reproduce the above copyright
#  *    notice, this list of conditions and the following disclaimer in the
#  *    documentation and/or other materials provided with the distribution.
#  * 3. Neither the name of the University nor the names of its contributors
#  *    may be used to endorse or promote products derived from this software
#  *    without specific prior written permission.
#  *
#  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
#  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
#  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
#  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
#  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
#  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
#  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
#  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
#  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
#  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
#  * SUCH DAMAGE.
#  *
#  * Posix rand_r function added May 1999 by Wes Peters <wes@softweyr.com>.
#  *
#  * $Id: random.c 1944 2009-04-01 23:12:20Z arcanum $
#  */
#
# /*
#  * From:
# static char sccsid[] = "@(#)rand.c	8.1 (Berkeley) 6/14/93";
# */
#
# #include <stdlib.h>
# #include "sectionname.h"
#
# ATTRIBUTE_CLIB_SECTION
# static long
# do_random(unsigned long *ctx)
# {
# 	/*
# 	 * Compute x = (7^5 * x) mod (2^31 - 1)
# 	 * wihout overflowing 31 bits:
# 	 *      (2^31 - 1) = 127773 * (7^5) + 2836
# 	 * From "Random number generators: good ones are hard to find",
# 	 * Park and Miller, Communications of the ACM, vol. 31, no. 10,
# 	 * October 1988, p. 1195.
# 	 */
# 	long hi, lo, x;
#
# 	x = *ctx;
# 	/* Can't be initialized with 0, so use another value. */
# 	if (x == 0)
# 		x = 123459876L;
# 	hi = x / 127773L;
# 	lo = x % 127773L;
# 	x = 16807L * lo - 2836L * hi;
# 	if (x < 0)
# 		x += 0x7fffffffL;
# 	return ((*ctx = x) % ((unsigned long)RANDOM_MAX + 1));
# }
#
#
# ATTRIBUTE_CLIB_SECTION
# long
# random_r(unsigned long *ctx)
# {
# 	return do_random(ctx);
# }
#
#
# static unsigned long next = 1;
#
# ATTRIBUTE_CLIB_SECTION
# long
# random(void)
# {
# 	return do_random(&next);
# }
#
# ATTRIBUTE_CLIB_SECTION
# void
# srandom(unsigned long seed)
# {
# 	next = seed;
# }

# should probably implement these with a class?
# peh

# icky global "next" for random
global rand_next, random_max
rand_next = 1
random_max = 0x7FFFFFFF

def do_random(ctx):
    global rand_next
    x = ctx
    # Can't be initialized with 0, so use another value.
    if (x == 0):
        x = 123459876
    hi = x // 127773       # // should be integer divide
    lo = x % 127773
    x = 16807 * lo - 2836 * hi
    if (x < 0):
        x += 0x7fffffff
    rand_next = x
    return x % (random_max + 1)


def random():
    global rand_next
    return do_random(rand_next)

def srandom(seed):
    global rand_next
    rand_next = seed;


# main -------------------------------------------------------------------------------------------


if __name__ == "__main__":
    print("Hello and welcome to PYBBAGE, the python cribbage mockup for my mcu cribbage games.")
    #print("Let's see some cards")
    #for j in range(0,53):
    #    print(j,cardstring(j))
    # print the first hundred million random numbers and see if they agree with the c version
    # which worked!
    #for j in range(0,100000000):
    #    print(random())